{"ast":null,"code":"/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport { keccak256 } from 'ethereum-cryptography/keccak.js';\nimport { bytesToHex, uint8ArrayEquals } from 'web3-utils';\nimport { secp256k1 } from './constants.js';\nimport { assertIsUint8Array, zeros } from '../common/utils.js';\nexport class Address {\n  constructor(buf) {\n    if (buf.length !== 20) {\n      throw new Error('Invalid address length');\n    }\n    this.buf = buf;\n  }\n  /**\n   * Returns the zero address.\n   */\n  static zero() {\n    return new Address(zeros(20));\n  }\n  /**\n   * Is address equal to another.\n   */\n  equals(address) {\n    return uint8ArrayEquals(this.buf, address.buf);\n  }\n  /**\n   * Is address zero.\n   */\n  isZero() {\n    return this.equals(Address.zero());\n  }\n  /**\n   * Returns hex encoding of address.\n   */\n  toString() {\n    return bytesToHex(this.buf);\n  }\n  /**\n   * Returns Uint8Array representation of address.\n   */\n  toArray() {\n    return this.buf;\n  }\n  /**\n   * Returns the ethereum address of a given public key.\n   * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n   * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n   * @param sanitize Accept public keys in other formats\n   */\n  static publicToAddress(_pubKey, sanitize = false) {\n    let pubKey = _pubKey;\n    assertIsUint8Array(pubKey);\n    if (sanitize && pubKey.length !== 64) {\n      pubKey = secp256k1.ProjectivePoint.fromHex(pubKey).toRawBytes(false).slice(1);\n    }\n    if (pubKey.length !== 64) {\n      throw new Error('Expected pubKey to be of length 64');\n    }\n    // Only take the lower 160bits of the hash\n    return keccak256(pubKey).slice(-20);\n  }\n}","map":{"version":3,"names":["keccak256","bytesToHex","uint8ArrayEquals","secp256k1","assertIsUint8Array","zeros","Address","constructor","buf","length","Error","zero","equals","address","isZero","toString","toArray","publicToAddress","_pubKey","sanitize","pubKey","ProjectivePoint","fromHex","toRawBytes","slice"],"sources":["../../../src/tx/address.ts"],"sourcesContent":[null],"mappings":"AAAA;;;;;;;;;;;;;;;;AAgBA,SAASA,SAAS,QAAQ,iCAAiC;AAC3D,SAASC,UAAU,EAAEC,gBAAgB,QAAQ,YAAY;AACzD,SAASC,SAAS,QAAQ,gBAAgB;AAC1C,SAASC,kBAAkB,EAAEC,KAAK,QAAQ,oBAAoB;AAE9D,OAAM,MAAOC,OAAO;EAGnBC,YAAmBC,GAAe;IACjC,IAAIA,GAAG,CAACC,MAAM,KAAK,EAAE,EAAE;MACtB,MAAM,IAAIC,KAAK,CAAC,wBAAwB,CAAC;;IAE1C,IAAI,CAACF,GAAG,GAAGA,GAAG;EACf;EAEA;;;EAGO,OAAOG,IAAIA,CAAA;IACjB,OAAO,IAAIL,OAAO,CAACD,KAAK,CAAC,EAAE,CAAC,CAAC;EAC9B;EAEA;;;EAGOO,MAAMA,CAACC,OAAgB;IAC7B,OAAOX,gBAAgB,CAAC,IAAI,CAACM,GAAG,EAAEK,OAAO,CAACL,GAAG,CAAC;EAC/C;EAEA;;;EAGOM,MAAMA,CAAA;IACZ,OAAO,IAAI,CAACF,MAAM,CAACN,OAAO,CAACK,IAAI,EAAE,CAAC;EACnC;EAEA;;;EAGOI,QAAQA,CAAA;IACd,OAAOd,UAAU,CAAC,IAAI,CAACO,GAAG,CAAC;EAC5B;EAEA;;;EAGOQ,OAAOA,CAAA;IACb,OAAO,IAAI,CAACR,GAAG;EAChB;EAEA;;;;;;EAMO,OAAOS,eAAeA,CAACC,OAAmB,EAAEC,QAAQ,GAAG,KAAK;IAClE,IAAIC,MAAM,GAAGF,OAAO;IACpBd,kBAAkB,CAACgB,MAAM,CAAC;IAC1B,IAAID,QAAQ,IAAIC,MAAM,CAACX,MAAM,KAAK,EAAE,EAAE;MACrCW,MAAM,GAAGjB,SAAS,CAACkB,eAAe,CAACC,OAAO,CAACF,MAAM,CAAC,CAACG,UAAU,CAAC,KAAK,CAAC,CAACC,KAAK,CAAC,CAAC,CAAC;;IAE9E,IAAIJ,MAAM,CAACX,MAAM,KAAK,EAAE,EAAE;MACzB,MAAM,IAAIC,KAAK,CAAC,oCAAoC,CAAC;;IAEtD;IACA,OAAOV,SAAS,CAACoB,MAAM,CAAC,CAACI,KAAK,CAAC,CAAC,EAAE,CAAC;EACpC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}