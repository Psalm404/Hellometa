{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\n/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport { FormatterError } from 'web3-errors';\nimport { FMT_BYTES, FMT_NUMBER } from 'web3-types';\nimport { isNullish, isObject, utils } from 'web3-validator';\nimport { bytesToUint8Array, bytesToHex, numberToHex, toBigInt } from './converters.js';\nimport { mergeDeep } from './objects.js';\nimport { padLeft } from './string_manipulation.js';\nimport { isUint8Array, uint8ArrayConcat } from './uint8array.js';\nconst {\n  parseBaseType\n} = utils;\nexport const isDataFormat = dataFormat => typeof dataFormat === 'object' && !isNullish(dataFormat) && 'number' in dataFormat && 'bytes' in dataFormat;\n/**\n * Finds the schema that corresponds to a specific data path within a larger JSON schema.\n * It works by iterating over the dataPath array and traversing the JSON schema one step at a time until it reaches the end of the path.\n *\n * @param schema - represents a JSON schema, which is an object that describes the structure of JSON data\n * @param dataPath - represents an array of strings that specifies the path to the data within the JSON schema\n * @param oneOfPath - represents an optional array of two-element tuples that specifies the \"oneOf\" option to choose, if the schema has oneOf and the data path can match multiple subschemas\n * @returns the JSON schema that matches the data path\n *\n */\nconst findSchemaByDataPath = (schema, dataPath, oneOfPath = []) => {\n  let result = Object.assign({}, schema);\n  let previousDataPath;\n  for (const dataPart of dataPath) {\n    if (result.oneOf && previousDataPath) {\n      const path = oneOfPath.find(function (element) {\n        return this === element[0];\n      }, previousDataPath !== null && previousDataPath !== void 0 ? previousDataPath : '');\n      if (path && path[0] === previousDataPath) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n        result = result.oneOf[path[1]];\n      }\n    }\n    if (!result.properties && !result.items) {\n      return undefined;\n    }\n    if (result.properties) {\n      result = result.properties[dataPart];\n    } else if (result.items && result.items.properties) {\n      const node = result.items.properties;\n      if (!node) {\n        return undefined;\n      }\n      result = node[dataPart];\n    } else if (result.items && isObject(result.items)) {\n      result = result.items;\n    } else if (result.items && Array.isArray(result.items)) {\n      result = result.items[parseInt(dataPart, 10)];\n    }\n    if (result && dataPart) previousDataPath = dataPart;\n  }\n  return result;\n};\n/**\n * Converts a value depending on the format\n * @param value - value to convert\n * @param ethType - The type of the value to be parsed\n * @param format - The format to be converted to\n * @returns - The value converted to the specified format\n */\nexport const convertScalarValue = (value, ethType, format) => {\n  try {\n    const {\n      baseType,\n      baseTypeSize\n    } = parseBaseType(ethType);\n    if (baseType === 'int' || baseType === 'uint') {\n      switch (format.number) {\n        case FMT_NUMBER.NUMBER:\n          return Number(toBigInt(value));\n        case FMT_NUMBER.HEX:\n          return numberToHex(toBigInt(value));\n        case FMT_NUMBER.STR:\n          return toBigInt(value).toString();\n        case FMT_NUMBER.BIGINT:\n          return toBigInt(value);\n        default:\n          throw new FormatterError(`Invalid format: ${String(format.number)}`);\n      }\n    }\n    if (baseType === 'bytes') {\n      let paddedValue;\n      if (baseTypeSize) {\n        if (typeof value === 'string') paddedValue = padLeft(value, baseTypeSize * 2);else if (isUint8Array(value)) {\n          paddedValue = uint8ArrayConcat(new Uint8Array(baseTypeSize - value.length), value);\n        }\n      } else {\n        paddedValue = value;\n      }\n      switch (format.bytes) {\n        case FMT_BYTES.HEX:\n          return bytesToHex(bytesToUint8Array(paddedValue));\n        case FMT_BYTES.UINT8ARRAY:\n          return bytesToUint8Array(paddedValue);\n        default:\n          throw new FormatterError(`Invalid format: ${String(format.bytes)}`);\n      }\n    }\n  } catch (error) {\n    // If someone didn't use `eth` keyword we can return original value\n    // as the scope of this code is formatting not validation\n    return value;\n  }\n  return value;\n};\n/**\n * Converts the data to the specified format\n * @param data - data to convert\n * @param schema - The JSON schema that describes the structure of the data\n * @param dataPath - A string array that specifies the path to the data within the JSON schema\n * @param format  - The format to be converted to\n * @param oneOfPath - An optional array of two-element tuples that specifies the \"oneOf\" option to choose, if the schema has oneOf and the data path can match multiple subschemas\n * @returns - The data converted to the specified format\n */\nexport const convert = (data, schema, dataPath, format, oneOfPath = []) => {\n  var _a, _b;\n  // If it's a scalar value\n  if (!isObject(data) && !Array.isArray(data)) {\n    return convertScalarValue(data, schema === null || schema === void 0 ? void 0 : schema.format, format);\n  }\n  const object = data;\n  for (const [key, value] of Object.entries(object)) {\n    dataPath.push(key);\n    const schemaProp = findSchemaByDataPath(schema, dataPath, oneOfPath);\n    // If value is a scaler value\n    if (isNullish(schemaProp)) {\n      delete object[key];\n      dataPath.pop();\n      continue;\n    }\n    // If value is an object, recurse into it\n    if (isObject(value)) {\n      convert(value, schema, dataPath, format);\n      dataPath.pop();\n      continue;\n    }\n    // If value is an array\n    if (Array.isArray(value)) {\n      let _schemaProp = schemaProp;\n      // TODO This is a naive approach to solving the issue of\n      // a schema using oneOf. This chunk of code was intended to handle\n      // BlockSchema.transactions\n      // TODO BlockSchema.transactions are not being formatted\n      if ((schemaProp === null || schemaProp === void 0 ? void 0 : schemaProp.oneOf) !== undefined) {\n        // The following code is basically saying:\n        // if the schema specifies oneOf, then we are to loop\n        // over each possible schema and check if they type of the schema\n        // matches the type of value[0], and if so we use the oneOfSchemaProp\n        // as the schema for formatting\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n        schemaProp.oneOf.forEach((oneOfSchemaProp, index) => {\n          var _a, _b;\n          if (!Array.isArray(schemaProp === null || schemaProp === void 0 ? void 0 : schemaProp.items) && (typeof value[0] === 'object' && ((_a = oneOfSchemaProp === null || oneOfSchemaProp === void 0 ? void 0 : oneOfSchemaProp.items) === null || _a === void 0 ? void 0 : _a.type) === 'object' || typeof value[0] === 'string' && ((_b = oneOfSchemaProp === null || oneOfSchemaProp === void 0 ? void 0 : oneOfSchemaProp.items) === null || _b === void 0 ? void 0 : _b.type) !== 'object')) {\n            _schemaProp = oneOfSchemaProp;\n            oneOfPath.push([key, index]);\n          }\n        });\n      }\n      if (isNullish(_schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items)) {\n        // Can not find schema for array item, delete that item\n        delete object[key];\n        dataPath.pop();\n        continue;\n      }\n      // If schema for array items is a single type\n      if (isObject(_schemaProp.items) && !isNullish(_schemaProp.items.format)) {\n        for (let i = 0; i < value.length; i += 1) {\n          object[key][i] = convertScalarValue(value[i],\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n          (_a = _schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items) === null || _a === void 0 ? void 0 : _a.format, format);\n        }\n        dataPath.pop();\n        continue;\n      }\n      // If schema for array items is an object\n      if (!Array.isArray(_schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items) && ((_b = _schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items) === null || _b === void 0 ? void 0 : _b.type) === 'object') {\n        for (const arrObject of value) {\n          convert(arrObject, schema, dataPath, format, oneOfPath);\n        }\n        dataPath.pop();\n        continue;\n      }\n      // If schema for array is a tuple\n      if (Array.isArray(_schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items)) {\n        for (let i = 0; i < value.length; i += 1) {\n          object[key][i] = convertScalarValue(value[i], _schemaProp.items[i].format, format);\n        }\n        dataPath.pop();\n        continue;\n      }\n    }\n    object[key] = convertScalarValue(value, schemaProp.format, format);\n    dataPath.pop();\n  }\n  return object;\n};\nexport const format = (schema, data, returnFormat) => {\n  let dataToParse;\n  if (isObject(data)) {\n    dataToParse = mergeDeep({}, data);\n  } else if (Array.isArray(data)) {\n    dataToParse = [...data];\n  } else {\n    dataToParse = data;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n  const jsonSchema = isObject(schema) ? schema : utils.ethAbiToJsonSchema(schema);\n  if (!jsonSchema.properties && !jsonSchema.items && !jsonSchema.format) {\n    throw new FormatterError('Invalid json schema for formatting');\n  }\n  return convert(dataToParse, jsonSchema, [], returnFormat);\n};","map":{"version":3,"names":["FormatterError","FMT_BYTES","FMT_NUMBER","isNullish","isObject","utils","bytesToUint8Array","bytesToHex","numberToHex","toBigInt","mergeDeep","padLeft","isUint8Array","uint8ArrayConcat","parseBaseType","isDataFormat","dataFormat","findSchemaByDataPath","schema","dataPath","oneOfPath","result","Object","assign","previousDataPath","dataPart","oneOf","path","find","element","properties","items","undefined","node","Array","isArray","parseInt","convertScalarValue","value","ethType","format","baseType","baseTypeSize","number","NUMBER","Number","HEX","STR","toString","BIGINT","String","paddedValue","Uint8Array","length","bytes","UINT8ARRAY","error","convert","data","object","key","entries","push","schemaProp","pop","_schemaProp","forEach","oneOfSchemaProp","index","_a","type","_b","i","arrObject","returnFormat","dataToParse","jsonSchema","ethAbiToJsonSchema"],"sources":["../../src/formatter.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}